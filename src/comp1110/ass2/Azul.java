package comp1110.ass2;

import java.util.*;

public class Azul {
    /**
     * We have 2 players, and accordingly 5 factories.
     * Created by u7235955.
     */
    public final int Max_Players_Number = 2;
    public final int Max_Factories_Number = 5;

    /**
     * In Azul, there are 100 tiles.
     * Created by u7235955.
     */
    public final int Tiles = 100;


    /**
     * Five colors for 100 tiles.
     * Created by u7235955.
     */
    enum Color {
        Blue('a'),
        Green('b'),
        Orange('c'),
        Purple('d'),
        Red('e');
        private char color;

        private Color(char ch) {
            this.color = ch;
        }
    }

    /**
     * state[0] represents shared state string, and state[1] represents player states string.
     * Created by u7235955.
     */
    public String[] state = new String[2];

    /**
     * Decide the color of tiles.
     * i can be generated by random() function.
     * Created by u7235955.
     */
    public char TileColor(int i) {
        if (i <= 20)
            return Color.Blue.color;
        if (i <= 40)
            return Color.Green.color;
        if (i <= 60)
            return Color.Orange.color;
        if (i <= 80)
            return Color.Purple.color;
        return Color.Red.color;
    }

    /**
     * Maybe the first method we call in the main method.
     * To set the state[0] shared state string, and state[1] player states string.
     * More specifically, to set factory 0 ~ 4 (randomly).
     * Created by u7235955.
     */
    public void GameStart() {

    }

    /**
     * We need to choose 4 * 5 tiles for 5 factories of 100 tiles randomly.
     * Created by u7235955.
     */
    public int RandomTiles() {
        return 0;
    }

    /**
     * Take an character as argument, find the index of it in s.
     * ch can be 'C', 'B', 'M' etc.
     * s can be the state[0] or state[1].
     * Created by u7235955.
     */
    public int FindIndex(String s, char ch) {
        return 0;
    }


    public static boolean is_factory_well_formed(String factory){
        if (factory.length() > 25) {
            return false;
        }
        if (factory.length() % 5 != 0) {
            return false;
        }
        for (int i = 0; i < factory.length(); i++) {
            if (i % 5 == 0) {
                if (factory.charAt(i) < 48 || factory.charAt(i) > 52) {
                    return false;
                }
            }
            if (i % 5 != 0) {
                if (factory.charAt(i) < 97 || factory.charAt(i) > 101) {
                    return false;
                }
            }
        }
        return true;
    }
    public static boolean is_centre_well_formed(String centre){
        if (centre.length()>17){
            return false;
        }
        for (int i=1;i<centre.length();i++){
            if (centre.charAt(i)<97||centre.charAt(i)>102){
                return false;
            }
        }
        for (int i=1;i<centre.length()-1;i++){
            if (centre.charAt(i)>centre.charAt(i+1)){
                return false;
            }
        }
        return true;
    }
    public static boolean is_bag_well_formed(String bag){
        if (bag.length() > 10) {
            return false;
        }
        for (int i = 0; i < bag.length(); i += 2) {
            if (bag.charAt(i) > 50 || bag.charAt(i) < 48) {
                return false;
            }
        }
        for (int i = 1; i < bag.length(); i += 2) {
            if (bag.charAt(i) > 57 || bag.charAt(i) < 48) {
                return false;
            }
        }
        return true;
    }
    public static boolean is_discard_well_formed(String discard){
        if (discard.length() > 10) {
            return false;
        }

        for (int i = 0; i < discard.length(); i += 2) {
            if (discard.charAt(i) > 50 || discard.charAt(i) < 48) {
                return false;
            }
        }
        for (int i = 1; i < discard.length(); i += 2) {
            if (discard.charAt(i) > 57 || discard.charAt(i) < 48) {
                return false;
            }
        }
        return true;
    }

    /**
     * Given a shared state string, determine if it is well-formed.
     * Note: you don't need to consider validity for this task.
     * A sharedState is well-formed if it satisfies the following conditions.
     * <p>
     * [turn][factories][centre][bag][discard]
     * where [turn][factories], [centre], [bag] and [discard] are replaced by the
     * corresponding small string as described below.
     * <p>
     * 0. [turn] The Turn substring is one character 'A'-'D' representing a
     * player, which indicates that it is this player's turn to make the next
     * drafting move. (In a two-player game, the turn substring can only take
     * the values 'A' or 'B').
     * <p>
     * 1. [factories] The factories substring begins with an 'F'
     * and is followed by a collection of *up to* 5 5-character factory strings
     * representing each factory.
     * Each factory string is defined in the following way:
     * 1st character is a sequential digit '0' to '4' - representing the
     * factory number.
     * 2nd - 5th characters are 'a' to 'e', alphabetically - representing
     * the tiles.
     * A factory may have between 0 and 4 tiles. If a factory has 0 tiles,
     * it does not appear in the factories string.
     * Factory strings are ordered by factory number.
     * For example: given the string "F1aabc2abbb4ddee": Factory 1 has tiles
     * 'aabc', Factory 2 has tiles 'abbb', Factory 4 has tiles 'ddee', and
     * Factories 0 and 4 are empty.
     * <p>
     * 2. [centre] The centre substring starts with a 'C'
     * This is followed by *up to* 15 characters.
     * Each character is 'a' to 'e', alphabetically - representing a tile
     * in the centre.
     * The centre string is sorted alphabetically.
     * For example: "Caaabcdde" The Centre contains three 'a' tiles, one 'b'
     * tile, one 'c' tile, two 'd' tile and one 'e' tile.
     * <p>
     * 3. [bag] The bag substring starts with a 'B'
     * and is followed by 5 2-character substrings
     * 1st substring represents the number of 'a' tiles, from 0 - 20.
     * 2nd substring represents the number of 'b' tiles, from 0 - 20.
     * 3rd substring represents the number of 'c' tiles, from 0 - 20.
     * 4th substring represents the number of 'd' tiles, from 0 - 20.
     * 5th substring represents the number of 'e' tiles, from 0 - 20.
     * <p>
     * For example: "B0005201020" The bag contains zero 'a' tiles, five 'b'
     * tiles, twenty 'c' tiles, ten 'd' tiles and twenty 'e' tiles.
     * 4. [discard] The discard substring starts with a 'D'
     * and is followed by 5 2-character substrings defined the same as the
     * bag substring.
     * For example: "D0005201020" The bag contains zero 'a' tiles, five 'b'
     * tiles, twenty 'c' tiles, ten 'd' tiles, and twenty 'e' tiles.
     *
     * @param sharedState the shared state - factories, bag and discard.
     * @return true if sharedState is well-formed, otherwise return false
     * TASK 2
     */

    public static boolean isSharedStateWellFormed(String sharedState) {
        String sharedState2 = sharedState.substring(1, sharedState.length());
        int f = sharedState2.indexOf("F");
        int c = sharedState2.indexOf("C");
        int b = sharedState2.indexOf("B");
        int d = sharedState2.indexOf("D");

        if (f==-1||c==-1||b==-1||d==-1){
            return false;
        }
        if (f>c||c>b||b>d){
            return false;
        }

        String factory = sharedState2.substring(f + 1, c);
        String centre=sharedState2.substring(c,b);
        String bag = sharedState2.substring(b + 1, d);
        String discard = sharedState2.substring(d + 1);

        if (sharedState.length() > 65) {
            return false;
        }
        if (is_factory_well_formed(factory)==false){
            return false;
        }
        if (is_centre_well_formed(centre)==false){
            return false;
        }
        if (is_bag_well_formed(bag)==false){
            return false;
        }
        if (is_discard_well_formed(discard)==false){
            return false;
        }
        // FIXME Task 2
        return true;
    }

    /** in task2, I divided sharedState into 4 part:factory,centre,bag,discard,and make boolean with each
     * other, and then mix them up got the final boolean of isSharedStateWellFormed
     *created by u7235221
     */

    /**
     * Given a playerState, determine if it is well-formed.
     * Note: you don't have to consider validity for this task.
     * A playerState is composed of individual playerStrings.
     * A playerState is well-formed if it satisfies the following conditions.
     * <p>
     * A playerString follows this pattern: [player][score][mosaic][storage][floor]
     * where [player], [score], [mosaic], [storage] and [floor] are replaced by
     * a corresponding substring as described below.
     * Each playerString is sorted by Player i.e. Player A appears before Player B.
     * <p>
     * 1. [player] The player substring is one character 'A' to 'D' -
     * representing the Player
     * <p>
     * 2. [score] The score substring is one or more digits between '0' and '9' -
     * representing the score
     * <p>
     * 3. [mosaic] The Mosaic substring begins with a 'M'
     * Which is followed by *up to* 25 3-character strings.
     * Each 3-character string is defined as follows:
     * 1st character is 'a' to 'e' - representing the tile colour.
     * 2nd character is '0' to '4' - representing the row.
     * 3rd character is '0' to '4' - representing the column.
     * The Mosaic substring is ordered first by row, then by column.
     * That is, "a01" comes before "a10".
     * <p>
     * 4. [storage] The Storage substring begins with an 'S'
     * and is followed by *up to* 5 3-character strings.
     * Each 3-character string is defined as follows:
     * 1st character is '0' to '4' - representing the row - each row number must only appear once.
     * 2nd character is 'a' to 'e' - representing the tile colour.
     * 3rd character is '0' to '5' - representing the number of tiles stored in that row.
     * Each 3-character string is ordered by row number.
     * <p>
     * 5. [floor] The Floor substring begins with an 'F'
     * and is followed by *up to* 7 characters in alphabetical order.
     * Each character is 'a' to 'f' - where 'f' represents the first player token.
     * There is only one first player token.
     * <p>
     * An entire playerState for 2 players might look like this:
     * "A20Ma02a13b00e42S2a13e44a1FaabbeB30Mc01b11d21S0e12b2F"
     * If we split player A's string into its substrings, we get:
     * [A][20][Ma02a13b00e42][S2a13e44a1][Faabbe].
     *
     * @param playerState the player state string
     * @return True if the playerState is well-formed,
     * false if the playerState is not well-formed
     * TASK 3
     */
    public static boolean isPlayerStateWellFormed(String playerState) {
        int b = playerState.indexOf("B");

        String playerState1 = playerState.substring(0, b);
        int m = playerState1.indexOf("M");
        int s = playerState1.indexOf("S");
        int f = playerState1.indexOf("F");

        if (m == -1 || s == -1 || f == -1) {
            return false;
        }

        String score = playerState1.substring(1, m);
        String mosaic = playerState1.substring(m + 1, s);
        String storage = playerState1.substring(s + 1, f);
        String floor = playerState1.substring(f + 1, b);


        if (playerState.charAt(0) < 65 || playerState.charAt(0) > 68) {
            return false;
        }

        for (int i = 0; i < score.length(); i++) {
            if (score.charAt(i) < 48 || score.charAt(i) > 57) {
                return false;
            }
        }

        if (mosaic.length() > 75) {
            return false;
        }
        for (int i = 0; i < mosaic.length(); i += 3) {
            if (mosaic.charAt(i) > 101 || mosaic.charAt(i) < 97) {
                return false;
            }
        }
        for (int i = 1; i < mosaic.length(); i += 3) {
            if (mosaic.charAt(i) > 52 || mosaic.charAt(i) < 48) {
                return false;
            }
        }
        for (int i = 2; i < mosaic.length(); i += 3) {
            if (mosaic.charAt(i) > 52 || mosaic.charAt(i) < 48) {
                return false;
            }
        }
        for (int i = 0; i < mosaic.length() - 3; i += 3) {
            if (mosaic.charAt(i) == mosaic.charAt(i + 3)) {
                if (mosaic.charAt(i + 1) > mosaic.charAt(i + 4)) {
                    return false;
                } else if (mosaic.charAt(i + 1) == mosaic.charAt(i + 4)) {
                    if (mosaic.charAt(i + 2) > mosaic.charAt(i + 5)) {
                        return false;
                    }
                }
            }
        }

        if (storage.length() > 15) {
            return false;
        }
        for (int i = 0; i < storage.length(); i += 3) {
            if (storage.charAt(i) < 48 || storage.charAt(i) > 52) {
                return false;
            }
        }
        for (int i = 0; i < storage.length() - 3; i += 3) {
            if (storage.charAt(i) == storage.charAt(i + 3)) {
                return false;
            }
            if (storage.charAt(i) > storage.charAt(i + 3)) {
                return false;
            }
        }

        for (int i = 1; i < storage.length(); i += 3) {
            if (storage.charAt(i) < 97 || storage.charAt(i) > 101) {
                return false;
            }
        }
        for (int i = 2; i < storage.length(); i += 3) {
            if (storage.charAt(i) < 48 || storage.charAt(i) > 53) {
                return false;
            }
        }
        for (int i = 0; i < floor.length(); i++) {
            if (floor.charAt(i) > 102 || floor.charAt(i) < 97) {
                return false;
            }
        }
        if (floor.length() > 7) {
            return false;
        }
        for (int i = 0; i < floor.length(); i++) {
            if (floor.charAt(i) == 102) {
                if (floor.indexOf("f") != i) {
                    return false;
                }
            }
        }

        String playerState2 = playerState.substring(b);
        int m2 = playerState2.indexOf("M");
        int s2 = playerState2.indexOf("S");
        int f2 = playerState2.indexOf("F");
        if (m2 == -1 || s2 == -1 || f2 == -1) {
            return false;
        }

        String score2 = playerState2.substring(1, m2);
        String mosaic2 = playerState2.substring(m2 + 1, s2);
        String storage2 = playerState2.substring(s2 + 1, f2);
        String floor2 = playerState2.substring(f2 + 1);


        if (playerState2.charAt(0) < 65 || playerState2.charAt(0) > 68) {
            return false;
        }

        for (int i = 0; i < score2.length(); i++) {
            if (score2.charAt(i) < 48 || score2.charAt(i) > 57) {
                return false;
            }
        }

        if (mosaic2.length() > 75) {
            return false;
        }
        for (int i = 0; i < mosaic2.length(); i += 3) {
            if (mosaic2.charAt(i) > 101 || mosaic2.charAt(i) < 97) {
                return false;
            }
        }
        for (int i = 1; i < mosaic2.length(); i += 3) {
            if (mosaic2.charAt(i) > 52 || mosaic2.charAt(i) < 48) {
                return false;
            }
        }
        for (int i = 2; i < mosaic2.length(); i += 3) {
            if (mosaic2.charAt(i) > 52 || mosaic2.charAt(i) < 48) {
                return false;
            }
        }
        for (int i = 0; i < mosaic2.length() - 3; i += 3) {
            if (mosaic2.charAt(i) == mosaic2.charAt(i + 3)) {
                if (mosaic2.charAt(i + 1) > mosaic2.charAt(i + 4)) {
                    return false;
                } else if (mosaic2.charAt(i + 1) == mosaic2.charAt(i + 4)) {
                    if (mosaic2.charAt(i + 2) > mosaic2.charAt(i + 5)) {
                        return false;
                    }
                }
            }
        }

        if (storage2.length() > 15) {
            return false;
        }
        for (int i = 0; i < storage2.length(); i += 3) {
            if (storage2.charAt(i) < 48 || storage2.charAt(i) > 52) {
                return false;
            }
        }
        for (int i = 0; i < storage2.length() - 3; i += 3) {
            if (storage2.charAt(i) == storage2.charAt(i + 3)) {
                return false;
            }
            if (storage2.charAt(i) > storage2.charAt(i + 3)) {
                return false;
            }
        }

        for (int i = 1; i < storage2.length(); i += 3) {
            if (storage2.charAt(i) < 97 || storage2.charAt(i) > 101) {
                return false;
            }
        }
        for (int i = 2; i < storage2.length(); i += 3) {
            if (storage2.charAt(i) < 48 || storage2.charAt(i) > 53) {
                return false;
            }
        }

        if (floor2.length() > 7) {
            return false;
        }
        for (int i = 0; i < floor2.length(); i++) {
            if (floor2.charAt(i) > 102 || floor2.charAt(i) < 97) {
                return false;
            }
        }
        for (int i = 0; i < floor2.length(); i++) {
            if (floor2.charAt(i) == 102) {
                if (floor2.indexOf("f") != i) {
                    return false;
                }
            }
        }
        // FIXME Task 3
        return true;
    }

    /** it's similar to task 3,but a little more complex
     * created by u7235221
     */

    /**
     * Given the gameState, draw a *random* tile from the bag.
     * If the bag is empty, refill the the bag with the discard pile and then draw a tile.
     * If the discard pile is also empty, return 'Z'.
     *
     * @param gameState the current game state
     * @return the tile drawn from the bag, or 'Z' if the bag and discard pile are empty.
     * TASK 5
     */
    public static char drawTileFromBag(String[] gameState) {
        // FIXME Task 5
        String sharedState = gameState[0];

        String sharedState2 = sharedState.substring(1, sharedState.length());
        int f = sharedState2.indexOf("F");
        int c = sharedState2.indexOf("C");
        int b = sharedState2.indexOf("B");
        int d = sharedState2.indexOf("D");

        String factory = sharedState2.substring(f + 1, c);
        String bag = sharedState2.substring(b + 1, d);
        String discard = sharedState2.substring(d + 1);

        if (bag.equals("0000000000") && discard.equals("0000000000")) {
            return 'Z';
        }
        /**
         System.out.println("Bag: " + bag);
         System.out.println("Discard: " + discard);
         */
        //System.out.println("sharedState:" + gameState[0]);
        if (bag.equals("0000000000")) {
            bag = discard;
            discard = "0000000000";
            gameState[0] = gameState[0].substring(0, b+1);
            gameState[0] += "B";
            gameState[0] += bag;
            gameState[0] += "D";
            gameState[0] += discard;
        }
        //System.out.println("sharedState:" + gameState[0]);
        String blue = bag.substring(0, 2);
        String green = bag.substring(2, 4);
        String orange = bag.substring(4, 6);
        String purple = bag.substring(6, 8);
        String red = bag.substring(8, 10);
        int blueTile = Integer.parseInt(blue);
        int greenTile = Integer.parseInt(green);
        int orangeTile = Integer.parseInt(orange);
        int purpleTile = Integer.parseInt(purple);
        int redTile = Integer.parseInt(red);


        /**
         System.out.println("Blue: " + blueTile);
         System.out.println("Green: " + greenTile);
         System.out.println("Orange: " + orangeTile);
         System.out.println("Purple: " + purpleTile);
         System.out.println("Red: " + redTile);
         */
        Random r = new Random();
        int random = r.nextInt(blueTile + greenTile + orangeTile + purpleTile + redTile);
        char tile;
        if (random < blueTile) {
            blueTile--;
            tile = Color.Blue.color;
        } else {
            if (random < blueTile + greenTile) {
                greenTile--;
                tile = Color.Green.color;
            } else {
                if (random < blueTile + greenTile + orangeTile) {
                    orangeTile--;
                    tile = Color.Orange.color;
                } else {
                    if (random < blueTile + greenTile + orangeTile + purpleTile) {
                        purpleTile--;
                        tile = Color.Purple.color;
                    } else {
                        tile = Color.Red.color;
                        redTile--;
                    }

                }
            }

        }
/**
 gameState[0] = gameState[0].substring(0, b + 1);
 gameState[0] += "B";
 String new_bag = "";
 if(blueTile < 10){
 new_bag += "0";
 }
 if(blueTile >= 0){
 new_bag += String.valueOf(blueTile);
 }

 if(greenTile < 10){
 new_bag += "0";
 }
 if(greenTile >= 0){
 new_bag += String.valueOf(greenTile);
 }
 if(orangeTile < 10){
 new_bag += "0";
 }
 if(orangeTile >= 0)
 {
 new_bag += String.valueOf(orangeTile);
 }
 if(purpleTile < 10){
 new_bag += "0";
 }
 if(purpleTile >= 0)
 {
 new_bag += String.valueOf(purpleTile);
 }

 if(redTile < 10){
 new_bag += "0";
 }
 if(redTile >= 0)
 {
 new_bag += String.valueOf(redTile);
 }

 gameState[0] += new_bag;
 gameState[0] += "D";
 gameState[0] += discard;
 */
        return tile;
    }

    public static boolean emptyMark(String s){
        return s.equals("00000000") ? true: false;
    }

    public static char drawTileFromBagForTask6(String[] gameState) {

        String sharedState = gameState[0];

        String sharedState2 = sharedState.substring(1, sharedState.length());
        int f = sharedState2.indexOf("F");
        int c = sharedState2.indexOf("C");
        int b = sharedState2.indexOf("B");
        int d = sharedState2.indexOf("D");

        String factory = sharedState2.substring(f + 1, c);
        String bag = sharedState2.substring(b + 1, d);
        String discard = sharedState2.substring(d + 1);

        if (emptyMark(bag) && emptyMark(discard)) {
            return 'Z';
        }
        /**
         System.out.println("Bag: " + bag);
         System.out.println("Discard: " + discard);
         */
        //System.out.println("sharedState:" + gameState[0]);
        if (bag.equals("0000000000")) {
            bag = discard;
            discard = "0000000000";
            gameState[0] = gameState[0].substring(0, b + 1);
            gameState[0] += "B";
            gameState[0] += bag;
            gameState[0] += "D";
            gameState[0] += discard;
        }
        //System.out.println("sharedState:" + gameState[0]);
        //updateBag(bag);
        String blue = bag.substring(0, 2);
        String green = bag.substring(2, 4);
        String orange = bag.substring(4, 6);
        String purple = bag.substring(6, 8);
        String red = bag.substring(8, 10);
        int blueTile = Integer.parseInt(blue);
        int greenTile = Integer.parseInt(green);
        int orangeTile = Integer.parseInt(orange);
        int purpleTile = Integer.parseInt(purple);
        int redTile = Integer.parseInt(red);


        /**
         System.out.println("Blue: " + blueTile);
         System.out.println("Green: " + greenTile);
         System.out.println("Orange: " + orangeTile);
         System.out.println("Purple: " + purpleTile);
         System.out.println("Red: " + redTile);
         */
        Random r = new Random();
        int random = r.nextInt(blueTile + greenTile + orangeTile + purpleTile + redTile);
        char tile;
        if (random < blueTile) {
            blueTile--;
            tile = Color.Blue.color;
        } else {
            if (random < blueTile + greenTile) {
                greenTile--;
                tile = Color.Green.color;
            } else {
                if (random < blueTile + greenTile + orangeTile) {
                    orangeTile--;
                    tile = Color.Orange.color;
                } else {
                    if (random < blueTile + greenTile + orangeTile + purpleTile) {
                        purpleTile--;
                        tile = Color.Purple.color;
                    } else {
                        tile = Color.Red.color;
                        redTile--;
                    }

                }
            }

        }
        int [] tiles = new int []{
                blueTile, greenTile, orangeTile, purpleTile, redTile
        };
        gameState[0] = gameState[0].substring(0, b + 1);
        gameState[0] += "B";
        String new_bag = updateBag(tiles);


        gameState[0] += new_bag;
        gameState[0] += "D";
        gameState[0] += discard;

        return tile;
    }

    public static String updateBag(int [] n){
        String new_bag = "";
        if (n[0] < 10) {
            new_bag += "0";
        }
        if (n[0] >= 0) {
            new_bag += String.valueOf(n[0]);
        }

        if (n[1] < 10) {
            new_bag += "0";
        }
        if (n[1] >= 0) {
            new_bag += String.valueOf(n[1]);
        }
        if (n[2] < 10) {
            new_bag += "0";
        }
        if (n[2] >= 0) {
            new_bag += String.valueOf(n[2]);
        }
        if (n[3] < 10) {
            new_bag += "0";
        }
        if (n[3] >= 0) {
            new_bag += String.valueOf(n[3]);
        }

        if (n[4] < 10) {
            new_bag += "0";
        }
        if (n[4] >= 0) {
            new_bag += String.valueOf(n[4]);
        }
        return new_bag;
    }

    /**
     * Given a state, refill the factories with tiles.
     * If the factories are not all empty, return the given state.
     *
     * @param gameState the state of the game.
     * @return the updated state after the factories have been filled or
     * the given state if not all factories are empty.
     * TASK 6
     */
    public static String[] refillFactories(String[] gameState) {
        // FIXME Task 6

        String sharedState = gameState[0];
        String sharedState2 = sharedState.substring(1, sharedState.length());
        int f = sharedState2.indexOf("F");
        int c = sharedState2.indexOf("C");
        int b = sharedState2.indexOf("B");
        int d = sharedState2.indexOf("D");

        String factory = sharedState2.substring(f + 1, c);
        String centre = sharedState2.substring(c, b);
        String bag = sharedState2.substring(b + 1, d);
        String discard = sharedState2.substring(d + 1);
        //System.out.println("sharedState:" + gameState[0]);
        String new_factory = "F";
        //System.out.println("Centre: " + centre);

        if (!factory.equals("") || !(centre.length() <= 2)){
            return gameState;
        }else{
            new_factory += updateFactory(gameState);
        }
        String temp = gameState[0].substring(c + 1, gameState[0].length());
        /**
        System.out.println("Temp: " + temp);
        System.out.println("New Factory: " + new_factory);
        System.out.println("sharedState: " + gameState[0]);
         */
        gameState[0] = gameState[0].substring(0, 1);
        gameState[0] += new_factory;
        gameState[0] += temp;
        //System.out.println("New sharedState: " + gameState[0]);
        return gameState;
    }

    public static String updateFactory(String [] gameState){
        String new_factory = new String();
        char tile = '0';
        for (int i = 0; i < 20; i++) {
            tile = Azul.drawTileFromBagForTask6(gameState);
            if (i % 4 == 0) {
                new_factory += String.valueOf(i / 4);
            }
            new_factory += String.valueOf(tile);
        }
        return new_factory;
    }

    /**
     * Given a gameState for a completed game,
     * return bonus points for rows, columns, and sets.
     *
     * @param gameState a completed game state
     * @param player    the player for whom the score is to be returned
     * @return the number of bonus points awarded to this player for rows,
     * columns, and sets
     * TASK 7
     */
    public static int getBonusPoints(String[] gameState, char player) {
        // FIXME Task 7
        String playerState = gameState[1];
        int b = playerState.indexOf("B");
        String playerState1 = "";
        if(player == 'B'){
            playerState1 = playerState.substring(b, playerState.length());;
        }else{
            playerState1 = playerState.substring(0, b);
        }

        int bonus = 0;


        int m = playerState1.indexOf("M");
        int s = playerState1.indexOf("S");

        //String score = playerState1.substring(1, m);
        String mosaic = playerState1.substring(m + 1, s);

        //System.out.println("PlayerState: " + playerState1);
        //System.out.println("Mosaic: " + mosaic);
        int [] row =new int[5];
        int [] column = new int[5];
        int [] tile = new int[5];
        for (int i = 0; i < mosaic.length(); i += 3) {
            tile[mosaic.charAt(i) - 'a'] += 1;
            row[mosaic.charAt(i + 1) - '0'] += 1;
            column[mosaic.charAt(i + 2) - '0'] += 1;
        }
        for (int i = 0; i < 5; i++) {
            if(tile[i] >= 5){
                bonus += 10;
            }
            if(row[i] >= 5){
                bonus += 2;
            }
            if(column[i] >= 5){
                bonus += 7;
            }
        }


        return bonus;
    }

    public static boolean isnextround(String[] gameState){
        String sharedState=gameState[0];
        String playerState=gameState[1];
        int f=sharedState.indexOf('F');
        int c=sharedState.indexOf('C');
        int b=playerState.indexOf('B');
        String stateA=playerState.substring(0,b);
        String stateB=playerState.substring(b);
        int s1=stateA.indexOf('S');
        int f1=stateA.indexOf('F');
        int s2=stateB.indexOf('S');
        int f2=stateB.indexOf('F');
        String factory=sharedState.substring(f,c);
        String storage1=stateA.substring(s1,f1);
        String storage2=stateB.substring(s2,f2);
        if (factory!="F"){
            return false;
        }
        for (int i=1;i<storage1.length();i+=3){
            if (storage1.charAt(i)+1==storage1.charAt(i+2)){
                return false;
            }
        }
        for (int i=1;i<storage2.length();i+=3){
            if (storage2.charAt(i)+1==storage2.charAt(i+2)){
                return false;
            }
        }
        return true;
    }
    /**
     * Given a valid gameState prepare for the next round.
     * 1. Empty the floor area for each player and adjust their score accordingly (see the README).
     * 2. Refill the factories from the bag.
     * * If the bag is empty, refill the bag from the discard pile and then
     * (continue to) refill the factories.
     * * If the bag and discard pile do not contain enough tiles to fill all
     * the factories, fill as many as possible.
     * * If the factories and centre contain tiles other than the first player
     * token, return the current state.
     *
     * @param gameState the game state
     * @return the state for the next round.
     * TASK 8
     */
    public static String[] nextRound(String[] gameState) {
        String[] temp = new String[]{gameState[0],gameState[1]};
        String playerState = temp[1];
        int A = playerState.indexOf('A'); //player A
        int B = playerState.indexOf('B');
        int C = playerState.indexOf('C');
        int D = playerState.indexOf('D');

        // build a array to contain each player
        String[] player = new String[4];
        if (A!= -1){
            if (B != -1) {
                player[0] = playerState.substring(A, B );
            }else if (C != -1) {
                player[0] = playerState.substring(A, C );
            }else if ( D!= -1){
                player[0] = playerState.substring(A, D );
            }else {
                player[0] = playerState.substring(A, playerState.length());
            }
        }
        if (B!= -1) {
            if (C != -1) {
                player[1] = playerState.substring(B, C );
            }else if ( D!= -1){
                player[1] = playerState.substring(B, D );
            }else {
                player[1] = playerState.substring(B, playerState.length());
            }
        }
        if (C!= -1) {
            if ( D!= -1) {
                player[2] = playerState.substring(C, D );
            }else {
                player[2] = playerState.substring(B, playerState.length());
            }
        }
        if (D!= -1) {
            player[3] = playerState.substring(D, playerState.length());
        }

        // build array store the information for Mosaic
        String[] mosaicArray = new String[4];
        for (int i = 0; i <4;i++){
            if(player[i]==null){
                continue;
            }
            int m = player[i].indexOf('M');
            int s = player[i].indexOf('S');
            mosaicArray[i] = player[i].substring(m,s);
        }
        //is End of game
        boolean isEndOfGame = isEndOfGame(mosaicArray);

        // build array store the score for floor
        String[] floorArray = new String[4];
        for (int i = 0; i <4;i++){
            if(player[i]==null){
                continue;
            }
            int f = player[i].indexOf('F');
            floorArray[i] = player[i].substring(f);
        }

        // calculate the floor
        int[] countFloor = new int[4];
        for (int i = 0; i < 4; i++) {
            if (floorArray[i] == null) {
                continue;}
            for (int j = 1; j < floorArray[i].length(); j++) {
                countFloor[i] += 1;
            }
        }
        for (int i =0; i<4; i++){
            if (countFloor[i] == 1){
                countFloor[i] = -1;
            }
            if (countFloor[i] == 2){
                countFloor[i] = -2;
            }
            if (countFloor[i] == 3){
                countFloor[i] = -4;
            }
            if (countFloor[i] == 4){
                countFloor[i] = -6;
            }
            if (countFloor[i] == 5){
                countFloor[i] = -8;
            }
            if (countFloor[i] == 6){
                countFloor[i] = -11;
            }
            if (countFloor[i] >= 7){
                countFloor[i] = -14;
            }
        }
        // isf
        boolean isf = false;
        char turn = ' ';
        la :for (int i = 0; i<4; i++){
            if (player[i] == null) {
                continue;
            }
            int f = player[i].indexOf('F');
            for(int j =f+1; j <player[i].length() ; j++){
                if (player[i].charAt(j) == 'f'){
                    turn = player[i].charAt(0);
                    isf = true;
                    break la;
                }
            }

        }

        //Empty the floor area for playerState (gameState[1])

        for (int i = 0; i<4; i++){
            if (player[i] == null){
                continue;
            }
            int f = player[i].indexOf('F');
            player[i]= player[i].substring(0,f+1);
        }

        // calculate the score
        //minus floor
        int[] bonus = new int[4];
        bonus[0] = getBonusPoints(gameState, 'A');
        bonus[1] = getBonusPoints(gameState, 'B');
        bonus[2] = getBonusPoints(gameState, 'C');
        bonus[3] = getBonusPoints(gameState, 'D');

        playerState ="";
        for (int i = 0; i <4;i++){
            if (player[i] == null){
                continue;
            }
            int M = player[i].indexOf('M'); //player A
            int F=player[i].indexOf('F');
            String score = player[i].substring(1, M);
            int scoreInt = Integer.valueOf(score) ;
            if (scoreInt + countFloor[i] >= 0 && isEndOfGame) {
                scoreInt = scoreInt + countFloor[i] + bonus[i]; // isEndOfGame then add bonus
            }else if (scoreInt + countFloor[i] >= 0 && !isEndOfGame){
                scoreInt = scoreInt + countFloor[i];
            }else if (scoreInt + countFloor[i] < 0 && isEndOfGame) {
                scoreInt = bonus[i];
            }else{
                scoreInt = 0;
            }
            score =Integer.toString(scoreInt);
            playerState += player[i].charAt(0) +score +player[i].substring(M,F)+'F';
        }

        temp[1] = playerState;
        if (isf){
            temp[0] = turn + temp[0].substring(1);
            gameState = refillFactories(temp);
        }
        if (isEndOfGame){
            int F = temp[0].indexOf('F');
            int C1 = temp[0].indexOf('C');
            temp[0]= temp[0].charAt(F) + temp[0].substring(C1) ;
        }

        return gameState;
    }

    public static boolean isEndOfGame(String[] mosaicArray){
        int[] count = new int[5];
        boolean isEndOfGame = false;
        for (int i = 0; i < 4;i++) {
            if (mosaicArray[i]==null){
                continue;
             }
            for (int j = 2; j < mosaicArray[i].length(); j += 3) {
                if (mosaicArray[i].charAt(j) == '0') {
                    count[0] += 1;
                    if (count[0]==5){
                        isEndOfGame =true;
                        break;
                    }
                }
                if (mosaicArray[i].charAt(j) == '1') {
                    count[1] += 1;
                    if (count[1]==5){
                    isEndOfGame =true;
                    break;
                    }
                }
                if (mosaicArray[i].charAt(j) == '2') {
                    count[2] += 1;
                    if (count[2]==5){
                    isEndOfGame =true;
                    break;
                    }
                }
                if (mosaicArray[i].charAt(j) == '3') {
                    count[3] += 1;
                    if (count[3]==5){
                    isEndOfGame =true;
                    break;
                    }
                }
                if (mosaicArray[i].charAt(j) == '4') {
                    count[4] += 1;
                    if (count[4]==5){
                    isEndOfGame =true;
                    break;
                    }
                }
            }
            count = new int[]{0, 0, 0, 0, 0};
        }
        return isEndOfGame;
    }

    public static boolean istilesnumber20(String[] gameState){
        String sharedState=gameState[0];
        String playerState=gameState[1];
        int b1=playerState.indexOf('B');
        String player1=playerState.substring(0,b1);
        String player2=playerState.substring(b1);
        int m1=player1.indexOf('M');
        int s1=player1.indexOf('S');
        int f1=player1.indexOf('F');
        String mosaic1=player1.substring(m1,s1);
        String storage1=player1.substring(s1,f1);
        String floor1=player1.substring(f1);
        int m2=player2.indexOf('M');
        int s2=player2.indexOf('S');
        int f2=player2.indexOf('F');
        String mosaic2=player2.substring(m2,s2);
        String storage2=player2.substring(s2,f2);
        String floor2=player2.substring(f2);
        int blue=0;
        int green=0;
        int orange=0;
        int purple=0;
        int red=0;
        for (int i=0;i<mosaic1.length();i++){
            if (mosaic1.charAt(i)==97){
                blue++;
            }
            if (mosaic1.charAt(i)==98){
                green++;
            }
            if (mosaic1.charAt(i)==99){
                orange++;
            }
            if (mosaic1.charAt(i)==100){
                purple++;
            }
            if (mosaic1.charAt(i)==101){
                red++;
            }
        }
        for (int i=0;i<mosaic2.length();i++){
            if (mosaic2.charAt(i)==97){
                blue++;
            }
            if (mosaic2.charAt(i)==98){
                green++;
            }
            if (mosaic2.charAt(i)==99){
                orange++;
            }
            if (mosaic2.charAt(i)==100){
                purple++;
            }
            if (mosaic2.charAt(i)==101){
                red++;
            }
        }
        for (int i=0;i<floor1.length();i++){
            if (floor1.charAt(i)==97){
                blue++;
            }
            if (floor1.charAt(i)==98){
                green++;
            }
            if (floor1.charAt(i)==99){
                orange++;
            }
            if (floor1.charAt(i)==100){
                purple++;
            }
            if (floor1.charAt(i)==101){
                red++;
            }
        }
        for (int i=0;i<floor2.length();i++){
            if (floor2.charAt(i)==97){
                blue++;
            }
            if (floor2.charAt(i)==98){
                green++;
            }
            if (floor2.charAt(i)==99){
                orange++;
            }
            if (floor2.charAt(i)==100){
                purple++;
            }
            if (floor2.charAt(i)==101){
                red++;
            }
        }
        for (int i=0;i<storage1.length();i++){
            if (storage1.charAt(i)==97){
                blue+=Integer.parseInt(storage1.substring(i+1,i+2));
            }
            if (storage1.charAt(i)==98){
                green+=Integer.parseInt(storage1.substring(i+1,i+2));
            }
            if (storage1.charAt(i)==99){
                orange+=Integer.parseInt(storage1.substring(i+1,i+2));
            }
            if (storage1.charAt(i)==100){
                purple+=Integer.parseInt(storage1.substring(i+1,i+2));
            }
            if (storage1.charAt(i)==101){
                red+=Integer.parseInt(storage1.substring(i+1,i+2));
            }
        }
        for (int i=0;i<storage2.length();i++){
            if (storage2.charAt(i)==97){
                blue+=Integer.parseInt(storage2.substring(i+1,i+2));
            }
            if (storage2.charAt(i)==98){
                green+=Integer.parseInt(storage2.substring(i+1,i+2));
            }
            if (storage2.charAt(i)==99){
                orange+=Integer.parseInt(storage2.substring(i+1,i+2));
            }
            if (storage2.charAt(i)==100){
                purple+=Integer.parseInt(storage2.substring(i+1,i+2));
            }
            if (storage2.charAt(i)==101){
                red+=Integer.parseInt(storage2.substring(i+1,i+2));
            }
        }



        for (int i=0;i<sharedState.length();i++){
            if (sharedState.charAt(i)==97){
                blue++;
            }
            if (sharedState.charAt(i)==98){
                green++;
            }
            if (sharedState.charAt(i)==99){
                orange++;
            }
            if (sharedState.charAt(i)==100){
                purple++;
            }
            if (sharedState.charAt(i)==101){
                red++;
            }
        }
        String sharedState2=sharedState.substring(1,sharedState.length());
        int b=sharedState2.indexOf('B');
        int d=sharedState2.indexOf('D');
        String bag=sharedState2.substring(b+1,d);
        String discard=sharedState2.substring(d+1,sharedState2.length());
        String bag_blue = bag.substring(0, 2);
        String bag_green = bag.substring(2, 4);
        String bag_orange = bag.substring(4, 6);
        String bag_purple = bag.substring(6, 8);
        String bag_red = bag.substring(8, 10);
        String discard_blue = discard.substring(0, 2);
        String discard_green = discard.substring(2, 4);
        String discard_orange = discard.substring(4, 6);
        String discard_purple = discard.substring(6, 8);
        String discard_red = discard.substring(8, 10);
        blue+=Integer.parseInt(bag_blue)+Integer.parseInt(discard_blue);
        green+=Integer.parseInt(bag_green)+Integer.parseInt(discard_green);
        orange+=Integer.parseInt(bag_orange)+Integer.parseInt(discard_orange);
        purple+=Integer.parseInt(bag_purple)+Integer.parseInt(discard_purple);
        red+=Integer.parseInt(bag_red)+Integer.parseInt(discard_red);
        if (blue!=20||green!=20||orange!=20||purple!=20||red!=20){
            return  false;
        }
        return true;
    }

    public static  boolean is_mosaic_valid(String playerState){
        int b=playerState.indexOf('B');
        String player1=playerState.substring(0,b);
        String player2=playerState.substring(b,playerState.length());
        int m1=player1.indexOf('M');
        int s1=player1.indexOf('S');
        String mosaic1=player1.substring(m1,s1);
        int m2=player2.indexOf('M');
        int s2=player2.indexOf('S');
        String mosaic2=player2.substring(m2,s2);
        if (mosaic1.length()>4){
            for (int i=2;i<mosaic1.length()-3;i+=3){
                if (mosaic1.charAt(i)==mosaic1.charAt(i+3)){
                    if (mosaic1.charAt(i+1)==mosaic1.charAt(i+4)){
                        return false;
                    }
                }
            }
        }
        if (mosaic2.length()>4){
            for (int i=2;i<mosaic2.length()-3;i+=3){
                if (mosaic2.charAt(i)==mosaic2.charAt(i+3)){
                    if (mosaic2.charAt(i+1)==mosaic2.charAt(i+4)){
                        return false;
                    }
                }
            }
        }
        if (mosaic1.length()>4){
            for (int i=2;i<mosaic1.length()-3;i+=3){
                if (mosaic1.charAt(i)==mosaic1.charAt(i+3)){
                    if (mosaic1.charAt(i-1)==mosaic1.charAt(i+2)){
                        return false;
                    }
                }
            }
        }
        if (mosaic2.length()>4){
            for (int i=2;i<mosaic2.length()-3;i+=3){
                if (mosaic2.charAt(i)==mosaic2.charAt(i+3)){
                    if (mosaic2.charAt(i-1)==mosaic2.charAt(i+2)){
                        return false;
                    }
                }
            }
        }
        if (mosaic1.length()>4){
            for (int i=3;i<mosaic1.length()-3;i+=3){
                if (mosaic1.charAt(i)==mosaic1.charAt(i+3)){
                    if (mosaic1.charAt(i-2)==mosaic1.charAt(i+1)){
                        return false;
                    }
                }
            }
        }
        if (mosaic2.length()>4){
            for (int i=3;i<mosaic2.length()-3;i+=3){
                if (mosaic2.charAt(i)==mosaic2.charAt(i+3)){
                    if (mosaic2.charAt(i-2)==mosaic2.charAt(i+1)){
                        return false;
                    }
                }
            }
        }
        return true;
    }

    public static boolean is_storage_valid(String[] gameState){
        String playerState=gameState[1];
        int b=playerState.indexOf('B');
        String player1=playerState.substring(0,b);
        String player2=playerState.substring(b,playerState.length());
        int m1=player1.indexOf('M');
        int m2=player2.indexOf('M');
        int s1=player1.indexOf('S');
        int f1=player1.indexOf('F');
        int s2=player2.indexOf('S');
        int f2=player2.indexOf('F');
        String storage1=player1.substring(s1,f1);
        String storage2=player2.substring(s2,f2);
        String mosaic1=player1.substring(m1,s1);
        String mosaic2=player2.substring(m2,s2);
        if (storage1.length()>1){
            for (int i=1;i<storage1.length();i+=3){
                if (storage1.charAt(i+2)>storage1.charAt(i)+1){
                    return false;
                }
            }
        }
        if (storage2.length()>1){
            for (int i=1;i<storage2.length();i+=3){
                if (storage2.charAt(i+2)>storage2.charAt(i)+1){
                    return false;
                }
            }
        }
        if (storage1.length()>1&&mosaic1.length()>1){
            for (int i=1;i<storage1.length();i+=3){
                for (int j=2;j<mosaic1.length();j+=3){
                    if (storage1.charAt(i)==mosaic1.charAt(j)){
                        if (storage1.charAt(i+1)==mosaic1.charAt(j-1)){
                            return false;
                        }
                    }
                }
            }
        }
        if (storage2.length()>1&&mosaic2.length()>1){
            for (int i=1;i<storage2.length();i+=3){
                for (int j=2;j<mosaic2.length();j+=3){
                    if (storage2.charAt(i)==mosaic2.charAt(j)){
                        if (storage2.charAt(i+1)==mosaic2.charAt(j-1)){
                            return false;
                        }
                    }
                }
            }
        }
        return true;
    }

    public static boolean is_floor_valid(String[] gameState){
        String playerState=gameState[1];
        int b=playerState.indexOf('B');
        String player1=playerState.substring(0,b);
        String player2=playerState.substring(b,playerState.length());
        int f1=player1.indexOf('F');
        String floor1=player1.substring(f1,player1.length());
        int f2=player2.indexOf('F');
        String floor2=player2.substring(f2,player2.length());
        if (floor1.length()>8){
            return false;
        }
        if (floor2.length()>8){
            return false;
        }
        return true;
    }

    public static  boolean is_centre_valid(String[] gameState){
        String sharedState=gameState[0];
        String sharedState2=sharedState.substring(1,sharedState.length());
        int f=sharedState2.indexOf('F');
        int c=sharedState2.indexOf('C');
        int b=sharedState2.indexOf('B');
        String centre=sharedState2.substring(c,b);
        String factory=sharedState2.substring(f,c);
        int count=0;
        for (int i=0;i<factory.length();i++){
            if (factory.charAt(i)>=48&&factory.charAt(i)<=52){
                count++;
            }
        }
        if (centre.length()>2+3*(5-count)){
            return false;
        }
        return true;
    }
    /**
     * Given an entire game State, determine whether the state is valid.
     * A game state is valid if it satisfies the following conditions.
     * <p>
     * [General]
     * 1. The game state is well-formed.
     * 2. There are no more than 20 of each colour of tile across all player
     * areas, factories, bag and discard
     * 3. Exactly one first player token 'f' must be present across all player
     * boards and the centre.
     * <p>
     * [Mosaic]
     * 1. No two tiles occupy the same location on a single player's mosaic.
     * 2. Each row contains only 1 of each colour of tile.
     * 3. Each column contains only 1 of each colour of tile.
     * [Storage]
     * 1. The maximum number of tiles stored in a row must not exceed (row_number + 1).
     * 2. The colour of tile stored in a row must not be the same as a colour
     * already found in the corresponding row of the mosaic.
     * <p>
     * [Floor]
     * 1. There are no more than 7 tiles on a single player's floor.
     * [Centre]
     * 1. The number of tiles in the centre is no greater than 3 * the number of empty factories.
     * [Factories]
     * 1. At most one factory has less than 4, but greater than 0 tiles.
     * Any factories with factory number greater than this factory must contain 0 tiles.
     *
     * @param gameState array of strings representing the game state.
     *                  state[0] = sharedState
     *                  state[1] = playerStates
     * @return true if the state is valid, false if it is invalid.
     * TASK 9
     */
    public static boolean isStateValid(String[] gameState) {
        String sharedState=gameState[0];
        String playerState=gameState[1];


        if (isSharedStateWellFormed(sharedState)==false){
            return false;
        }
        if (isPlayerStateWellFormed(playerState)==false){
            return false;
        }
        if (istilesnumber20(gameState)==false){
            return false;
        }
        int count_f=0;
        for (int i=0;i<sharedState.length();i++){
            if (sharedState.charAt(i)==102){
                count_f++;
            }
        }
        for (int i=0;i<playerState.length();i++){
            if (playerState.charAt(i)==102){
                count_f++;
            }
        }
        if (count_f>1){
            return  false;
        }
        if (is_mosaic_valid(playerState)==false){
            return false;
        }
        if (is_storage_valid(gameState)==false){
            return false;
        }
        if (is_floor_valid(gameState)==false){
            return false;
        }
        if (is_centre_valid(gameState)==false){
            return false;
        }

        // FIXME Task 9
        return true;
    }

    /**
     * Given a valid gameState and a move, determine whether the move is valid.
     * A Drafting move is a 4-character String.
     * A Drafting move is valid if it satisfies the following conditions:
     * <p>
     * 1. The specified factory/centre contains at least one tile of the specified colour.
     * 2. The storage row the tile is being placed in does not already contain a different colour.
     * 3. The corresponding mosaic row does not already contain a tile of that colour.
     * Note that the tile may be placed on the floor.
     * </p>
     * <p>
     * A Tiling move is a 3-character String.
     * A Tiling move is valid if it satisfies the following conditions:
     * 1. The specified row in the Storage area is full.
     * 2. The specified column does not already contain a tile of the same colour.
     * 3. The specified location in the mosaic is empty.
     * 4. If the specified column is 'F', no valid move exists from the
     * specified row into the mosaic.
     * </p>
     *
     * @param gameState the game state.
     * @param move      A string representing a move.
     * @return true if the move is valid, false if it is invalid.
     * TASK 10
     */
    public static boolean isMoveValid(String[] gameState, String move) {

        if(!isPlayerTurn(gameState, move)){
            return false;
        }
        //move may contains 4 characters, 3 characters without "F" in it, or 3 characters with "F" in it
        if(move.length() == 4){
            return isTileExist(gameState, move) && isMosaicContains(gameState, move);
        }else{
            return isMosaicAvailable(gameState, move);
        }
        //return false;
    }

    //Check the String move with length of 3 without "F" in it
    public static boolean isMosaicAvailable(String [] gameState, String move){
        String playerState = gameState[1];
        int b = playerState.indexOf("B");
        String playerState1 = "";
        if(move.charAt(0) == 'B'){
            playerState1 = playerState.substring(b, playerState.length());;
        }else{
            playerState1 = playerState.substring(0, b);
        }

        int m = playerState1.indexOf("M");
        int s = playerState1.indexOf("S");
        int f = playerState1.indexOf("F");

        String mosaic = playerState1.substring(m, s);
        String storage = playerState1.substring(s, f);
        //System.out.println("Mosaic: " + mosaic
        //+ System.lineSeparator() + "Storage: " + storage);

        String row = String.valueOf(move.charAt(1));
        if (move.indexOf("F") == -1){
            // row is null in storage
            if(storage.indexOf(row) == -1){
                return false;
            }else{
                if(!isRowFull(storage, row) && move.indexOf("F")  == -1){
                    return false;
                }else{
                    if(!isMosaicContains(gameState, move)){
                        return false;
                    }else{
                        return !isColumnContainsColor(storage, mosaic, move);
                    }
                }
            }
        }else{
            return isColumnContainsColorForF(storage, mosaic, move);
                    //&& noOtherValidMove();
        }
    }

    public static int [] rowState(String mosaic, int row){
        int [] rowArr = new int[5];
        int start = 0;
        int end = 0;
        //System.out.println("Mosaic: " + mosaic);
        for (int i = 2; i < mosaic.length(); i += 3){
            if (start == 0){
                if(mosaic.charAt(i) - '0' == row){
                    start = i - 1;
                    //System.out.println("start = " + start);
                }
            } else {
                if(mosaic.charAt(i) - '0' != row) {
                    end = i - 1;
                    //System.out.println("end = " + end);
                    break;
                }
            }
        }
        String temp;
        if(end == 0){
            temp = mosaic.substring(start);
        } else{
            temp = mosaic.substring(start, end);
        }

        //System.out.println("Temp: " + temp);
        for (int i = 2; i < temp.length(); i += 3) {
            rowArr[temp.charAt(i) -'0'] += 1;
        }
        return rowArr;
    }

    public static int [] columnState(String mosaic, String tile){
        int [] columnArr = new int [5];
        int i = 0;
        //System.out.println("Mosaic: " + mosaic);
        //System.out.println("tile = " + tile);
        while(mosaic.indexOf(tile, i) != -1){
            int temp = mosaic.indexOf(tile, i);
            if (temp + 2 >= mosaic.length()){
                return columnArr;
            }
            //System.out.println("temp = " + temp);
            //System.out.println("mosaic = " + mosaic);
            //System.out.print("mosaic.charAt(temp + 2) = " + mosaic.charAt(temp + 2) + System.lineSeparator());
            columnArr[mosaic.charAt(temp + 2) - '0'] +=1;
            i = temp + 1;
        }
        return columnArr;
    }

    public static boolean isColumnContainsColorForF(String storage, String mosaic, String move){
        String row = String.valueOf(move.charAt(1));
        int rowInt = Integer.parseInt(row);
        int row_position = 0;
        if (storage.indexOf(row) == -1){
            return false;
        }
        for(int i = 1; i < storage.length(); i += 3){
            if(String.valueOf(storage.charAt(i)).equals(row)){
                row_position = i;
            }
        }
        String color = String.valueOf(storage.charAt(row_position + 1));
       // System.out.println(storage);
        //System.out.println(row_position);
        if (row_position <= 0){
            return false;
        }
        int [] rowArr = rowState(mosaic, rowInt);
        //System.out.println(color);
        int [] columnArr = columnState(mosaic, color);

        for (int i = 0; i < rowArr.length; i++) {
            if(rowArr[i] == 0 && columnArr[i] == 0){
                return false;
            }
        }
        return true;
    }

    //If the column of mosaic contains that color, return true.
    public static boolean isColumnContainsColor(String storage, String mosaic, String move){
        String row = String.valueOf(move.charAt(1));
        int rowInt = Integer.parseInt(row);
        int row_position = 0;
        for(int i = 1; i < storage.length(); i += 3){
            if(String.valueOf(storage.charAt(i)).equals(row)){
                row_position = i;
            }
        }
        //System.out.println("Move: " + move);

        String color = String.valueOf(storage.charAt(row_position + 1));

        String [] temp = new String[5];
        for (int i = 0; i < temp.length; i++) {
            temp[i] = color + i + String.valueOf(move.charAt(2)) /**(move.indexOf("F") == -1 ? String.valueOf(move.charAt(2)): "Z")*/;
        }
        if(move.indexOf("F") == -1){
            for (int i = 0; i < temp.length; i++) {
                if(mosaic.indexOf(temp[i]) != -1){
                    return true;
                }
            }
        }else{

            int [] rowArr = rowState(mosaic, rowInt);
            int [] columnArr = columnState(mosaic, color);

            for (int i = 0; i < rowArr.length; i++) {
                if(rowArr[i] == 0 && columnArr[i] == 0){
                    return true;
                }
            }
            return false;
        }


        return false;
        //return mosaic.indexOf(temp) == -1? false: true;
    }

    //Row is the row number in string move, return false if the row is not full
    public static boolean isRowFull(String storage, String row){
        int row_position = storage.indexOf(row);

        if (row_position + 2 >= storage.length()){
            return false;
        }
        String real_number = String.valueOf(storage.charAt(row_position + 2) - '0' - 1);
        //System.out.println("Real: " + real_number);
        //System.out.println("Row: " + row);
        if(row.equals(real_number)){
            return true;
        }

        return false;
    }

    //Return false if it's not that player's turn
    public static boolean isPlayerTurn(String [] gameState, String move){
        return gameState[0].charAt(0) == move.charAt(0);
    }

    //Return true if the tile exist in that factory
    public static boolean isTileExist(String [] gameState, String move){
        String sharedState = gameState[0];

        String sharedState2 = sharedState.substring(1, sharedState.length());
        int f = sharedState2.indexOf("F");
        int c = sharedState2.indexOf("C");
        int b = sharedState2.indexOf("B");
        int d = sharedState2.indexOf("D");

        String factory = sharedState2.substring(f, c);
        String centre = sharedState2.substring(c, b);
        String discard = sharedState2.substring(d);

        if(move.indexOf("C") != -1) {
            String tile = String.valueOf(move.charAt(2));
            if(centre.indexOf(tile) != -1){
                return true;
            }
            return false;
        }

        //System.out.println("Factory: " + factory + System.lineSeparator()
        //+ "Centre: " + centre + System.lineSeparator() + "Discard:" + discard);

        int factory_number = move.charAt(1) - '0';
        //System.out.println("Move:" + move);
        String fact;
        int start = factory.indexOf(String.valueOf(factory_number));
        int end = start + 5;
        fact = factory.substring(start, end);


        //System.out.println("from: " + fact);
        char tile = move.charAt(2);
        if(fact.indexOf(String.valueOf(tile)) != -1){
            return true;
        }
        return false;
    }

    //If the player's mosaic already contains the tile in that row, return false
    public static boolean isMosaicContains(String [] gameState, String move){

        String playerState = gameState[1];
        int b = playerState.indexOf("B");
        String playerState1 = "";
        if(move.charAt(0) == 'B'){
            playerState1 = playerState.substring(b, playerState.length());;
        }else{
            playerState1 = playerState.substring(0, b);
        }

        int m = playerState1.indexOf("M");
        int s = playerState1.indexOf("S");

        //String score = playerState1.substring(1, m);
        String mosaic = playerState1.substring(m, s);
        String temp = move.substring(move.length() - 2, move.length());
        //System.out.println("Mosaic: " + mosaic);
        //System.out.println("Temp: " + temp);
        if(mosaic.indexOf(temp) != -1){
            return false;
        }
        return true;
    }

    /**
     * Given a gameState and a move, apply the move to the gameState.
     * If the move is a Tiling move, you must also update the player's score.
     * If the move is a Tiling move, you must also empty the remaining tiles
     * into the discard.
     * If the move is a Drafting move, you must also move any remaining tiles
     * from the specified factory into the centre.
     * If the move is a Drafting move and you must put tiles onto the floor,
     * any tiles that cannot fit on the floor are placed in the discard with
     * the following exception:
     * If the first player tile would be placed into the discard, it is instead
     * swapped with the last tile in the floor, when the floor is sorted
     * alphabetically.
     *
     * @param gameState the game state.
     * @param move      A string representing a move.
     * @return the updated gameState after the move has been applied.
     * TASK 11
     */
    public static String[] applyMove(String[] gameState, String move) {
        /**
         * The move is a Tiling move.
         * Update the player's score,
         * and empty the remaining tiles
         * into the discard.
         */
        if(move.length() == 3){
            emptyStorageRow(gameState, move);
            updateScore(gameState, move);
        } else {
            /**
             * The move is a Drafting move.
             */
            moveTiles(gameState, move);
        }
        return gameState;
    }

    /**
     * The main method for task 11, specifically for the drafting move.
     * @param gameState
     * @param move
     * @author u7235955
     */
    public static void moveTiles (String [] gameState, String move){
        String sharedState = gameState[0];
        String sharedState2 = sharedState.substring(1, sharedState.length());
        int f = sharedState2.indexOf("F");
        int c = sharedState2.indexOf("C");
        int b = sharedState2.indexOf("B");
        int d = sharedState2.indexOf("D");
        String factory = sharedState2.substring(f, c);
        String centre = sharedState2.substring(c, b);
        String bag = sharedState2.substring(b, d);
        String discard = sharedState2.substring(d);

        String fac_numStr = String.valueOf(move.charAt(1));
        String tile = String.valueOf(move.charAt(2));
        String row = String.valueOf(move.charAt(3));
        int pos = factory.indexOf(fac_numStr);
        String fac = "";
        if (factory.length() < 4) {
            fac = factory;
        }else {
            fac = factory.substring(pos + 1, pos + 5);
        }
        int tile_number = 0;

        //System.out.println(fac);
        for (int i = 0; i < fac.length(); i++) {
            if (tile.charAt(0) == fac.charAt(i)) {
                tile_number += 1;
            }
        }
        if (move.indexOf("C") != -1){
            tile_number = 0;
        }
        String new_factory = factory;
        String new_centre = centre;
        boolean tile_f_move = false;
        // Implies this isn't a move from centre.
        if (move.indexOf("C") == -1) {
            String [] temp = updateFactoryAndCentre(factory, centre, fac_numStr, tile);
            new_factory = temp[0];
            new_centre = temp[1];
        } else {
            for (int i = 0; i < new_centre.length(); i++) {
                if (tile.charAt(0) == new_centre.charAt(i)) {
                    tile_number += 1;
                }
            }
            int start = new_centre.indexOf(tile);
            int end = new_centre.lastIndexOf(tile);
            if (new_centre.length() - 1 == end) {
                new_centre = new_centre.substring(0, start);
                tile_f_move = false;
            } else {
                new_centre = new_centre.substring(0, start) + new_centre.substring(end + 1, new_centre.length() - 1);
                if (centre.indexOf("f") != -1) {
                    tile_f_move = true;
                } else {
                    new_centre += centre.substring(centre.length() - 1);
                }
            }
        }
        String new_shared_state = "";
        boolean empty =false;
        if (new_centre.length() < 2 && new_factory.length() < 2) {
            empty = true;
        }
        String mark = gameState[0].substring(0, 1);
        new_shared_state += new_factory + new_centre + bag + discard;
        gameState[0] = new_shared_state;
        //System.out.println("new_shared_state = " +new_shared_state );
        String playerState = gameState[1];
        String playerState1 = "";
        String left = "";
        int B = playerState.indexOf("B");
        if(move.charAt(0) == 'B'){
            playerState1 = playerState.substring(B);
            left = playerState.substring(0, B);
        }else{
            playerState1 = playerState.substring(0, B);
            left = playerState.substring(B);
        }

        int m = playerState1.indexOf("M");
        int s = playerState1.indexOf("S");
        int F = playerState1.indexOf("F");

        String mosaic = playerState1.substring(m, s);
        String storage = playerState1.substring(s, F);
        String floor = playerState1.substring(F);
        int rowInt = 0;
        if (!row.equals("F")){
            rowInt = Integer.parseInt(row) + 1;
            if (rowInt < tile_number){
                floor = updateFloor(floor, tile, tile_number - rowInt);
                tile_number = rowInt;
            }
            if (tile_f_move){
                floor += "f";
            }
        } else {
            //System.out.println(playerState1);
            int start = centre.indexOf(tile);
            int end = centre.lastIndexOf(tile);
            floor = updateFloor(floor, tile, tile_number);
            if (end - start + 1 >= floor.length() - 1){
                floor = floor.substring(0, floor.length() - 1);
                floor += "f";
                discard = updateDiscard(discard, tile, floor.length() - (end - start));
                new_shared_state = new_shared_state.substring(0, new_shared_state.indexOf("D"))
                        + discard;
            }
        }

        String [] tempArr = updateStorage(storage, row, tile, tile_number, floor);
        String new_storage = storage;
        if (row.equals("F")){
            ;
        } else {
            new_storage = tempArr[0];
            floor = tempArr[1];
        }



        String new_player_state = playerState1.substring(0, s);
        new_player_state += new_storage + floor;
        if(move.charAt(0) == 'B'){
            new_player_state = left + new_player_state;
        }else{
            new_player_state = new_player_state + left;
        }
        gameState[1] = new_player_state;
        if ((empty && !isTurn(new_storage))) {
            gameState[0] = mark + new_shared_state;
        } else {
            if (mark.equals("A")){
                gameState[0] = "B" + new_shared_state;
            } else {
                gameState[0] = "A" + new_shared_state;
            }
        }
    }

    /**
     * A tile moving action may change the floor state.
     * @param floor
     * @param tile
     * @param number
     * @return
     * @author u7235955
     */
    public static String updateFloor (String floor, String tile, int number) {
        if (floor.length() < 2){
            while (number > 0) {
                floor += tile;
                number --;
            }
            return floor;
        }
        for (int i = 1; i < floor.length(); i++) {
            if (floor.charAt(i) >= tile.charAt(0)) {
                String temp = floor.substring(0, i);
                while (number > 0) {
                    temp += tile;
                    number --;
                }
                temp += floor.substring(i);
                floor = temp;
                break;
            }else {
                if (i == floor.length() - 1){
                    if (floor.indexOf("f") == -1){
                        while (number > 0) {
                            floor += tile;
                            number --;
                        }
                    }else {
                        String temp = floor.substring(0, floor.length() - 1);
                        while (number > 0) {
                            temp += tile;
                            number --;
                        }
                        temp += tile + "f";
                        floor = temp;
                    }
                    break;
                } else {
                    continue;
                }
            }
        }
        if (floor.length() >= 8){
            System.out.println("I am here!");
            floor += "f";
        }
        return floor;
    }

    /**
     * After moving tiles, update the storage area in player state.
     * @param storage
     * @param row
     * @param tile
     * @param tile_number
     * @param floor
     * @return
     * @author u7235955
     */
    public static String [] updateStorage (String storage, String row, String tile, int tile_number,
                                        String floor) {
        String [] tempArr = new String[] {storage, floor};
        if (storage.length() < 2) {
            storage += row;
            storage += tile;
            storage += tile_number;
            tempArr[0] = storage;
            return tempArr;
        }
        for (int i = 1; i < storage.length(); i+=3) {
            if (row.charAt(0) <= storage.charAt(i)) {
                if (row.charAt(0) == storage.charAt(i)){
                    int number = storage.charAt(i + 2) - '0';
                    tile_number += number;
                    int rowInt = row.charAt(0) + 1 - '0';
                    if (tile_number > rowInt) {
                        floor = updateFloor(floor, tile, tile_number - rowInt);
                        tile_number = rowInt;
                    }
                    String temp = storage.substring(0, i + 2);
                    temp += tile_number;
                    temp +=  storage.substring(i + 3);
                    storage = temp;
                }
                 else {
                    String temp = storage.substring(0, i);
                    temp += row;
                    temp += tile;
                    temp += tile_number;
                    temp +=  storage.substring(i);
                    storage = temp;
                }
                break;
            } else {
                if (i + 3 >= storage.length()) {
                    storage += row + tile + tile_number;
                    break;
                }
            }
        }
        tempArr[0] = storage;
        tempArr[1] = floor;
        return tempArr;
    }

    /**
     * After moving tiles, update factories and centre  shared state.
     * @param factory
     * @param centre
     * @param fac_numStr
     * @param tile
     * @return
     * @author u7235955
     */
    public static String [] updateFactoryAndCentre (String factory, String centre,
                                                    String fac_numStr, String tile) {
        String[] temp = new String[2];
        String new_factory = "";
        int pos = factory.indexOf(fac_numStr);
        new_factory = factory.substring(0, pos) + factory.substring(pos + 5);
        //System.out.println(new_factory);
        temp[0] = new_factory;
        String tiles = factory.substring(pos + 1, pos + 5);
        //System.out.println(tiles);
        for (int i = 0; i < tiles.length(); i++) {
            if (!String.valueOf(tiles.charAt(i)).equals(tile)){
                if (centre.length() < 2){
                    centre += String.valueOf(tiles.charAt(i));
                } else {
                    centre = insertIntoCentre (centre, String.valueOf(tiles.charAt(i)));
                }
            } else {
                continue;
            }
        }
        temp[1] = centre;
        return temp;
    }

    /**
     * To insert new tiles into the centre and keep the centre in the order.
     * @param centre
     * @param tile
     * @return ordered string centre
     * @author u7235955
     */

    public static String insertIntoCentre (String centre, String tile) {
        for (int i = 1; i < centre.length(); i++) {
            if (centre.charAt(i) >= tile.charAt(0)) {
                String temp = centre.substring(0, i);
                temp += tile;
                temp += centre.substring(i);
                centre = temp;
                break;
            } else {
                if (i == centre.length() - 1){
                    if (centre.indexOf("f") == -1){
                        centre += tile;
                    }else {
                        String temp = centre.substring(0, centre.length() - 1);
                        temp += tile + "f";
                        centre = temp;
                    }
                    break;
                } else {
                    continue;
                }
            }
        }
        return centre;
    }

    /**
     * @param gameState
     * @param move
     * @author u7235955
     */
    public static void updateScore(String [] gameState, String move){
        String playerState = gameState[1];
        int b = playerState.indexOf("B");
        String playerState1 = "";
        String left = "";
        if(move.charAt(0) == 'B'){
            playerState1 = playerState.substring(b + 1, playerState.length());
            left = playerState.substring(0, b);
        }else{
            playerState1 = playerState.substring(0, b);
            left = playerState.substring(b);
        }

        int m = playerState1.indexOf("M");
        int s = playerState1.indexOf("S");
        String mosaic = playerState1.substring(m, s);
        int sc = Integer.parseInt(playerState1.substring(1, m));
        int score = countScore(mosaic, move, sc);
        //System.out.println("score = " + score);
        String temp = playerState1.substring(m);
        String new_state = playerState1.substring(0, 1);
        if(move.charAt(0) == 'B'){
            new_state =left + new_state + score + temp;
        }else{
            new_state = new_state + score + temp + left;
        }
        gameState[1] = new_state;
    }

    /**
     * This method is for tiling move, which update the player state definitely, including the
     * mosaic, storage, score, and may also change the discard in the gameState[0].
     * @param gameState
     * @param move
     * @author u7235955
     */
    public static void emptyStorageRow(String [] gameState, String move){
        String playerState = gameState[1];
        int b = playerState.indexOf("B");
        String playerState1 = "";
        String left = "";
        if(move.charAt(0) == 'B'){
            left = playerState.substring(0, b + 1);
            playerState1 = playerState.substring(b, playerState.length());;
        }else{
            left = playerState.substring(b);
            playerState1 = playerState.substring(0, b);
        }

        int m = playerState1.indexOf("M");
        int s = playerState1.indexOf("S");
        int f = playerState1.indexOf("F");

        String mosaic = playerState1.substring(m, s);
        String storage = playerState1.substring(s, f);
        String floor = playerState1.substring(f);
        String new_state = playerState1.substring(0, m);
        String row = String.valueOf(move.charAt(1));
        int row_position = 0;
        int tile_count = 0;
        String tile = "";
        for(int i = 1; i < storage.length(); i += 3){
            if(String.valueOf(storage.charAt(i)).equals(row)){
                row_position = i;
                tile = String.valueOf(storage.charAt(i + 1));
                tile_count = storage.charAt(i + 2) - '0';
                break;
            }
        }
        // To get new storage.
        String new_storage = updateStorage(storage, row_position, tile, tile_count);
        //System.out.println("new_storage = " + new_storage);
        // To get new mosaic.
        String new_mosaic = updateMosaic(mosaic, tile, move);
        if(move.charAt(0) == 'B'){
            new_state = left + new_state + new_mosaic + new_storage + floor;
        }else{
            new_state = new_state + new_mosaic + new_storage + floor + left;
        }
        if (tile_count != 1){
            String sharedState = gameState[0].substring(0);
            int d = sharedState.indexOf("D");
            String discard = sharedState.substring(d);
            String new_discard = updateDiscard(discard, tile, tile_count);
            String temp = gameState[0].substring(0, d);
            gameState[0] = temp + new_discard;
        }
        gameState[1] = new_state;

        boolean turn = isTurn (new_storage);

        if (turn){
            String temp = gameState[0].substring(1);
            if(gameState[0].charAt(0) == 'A'){
                gameState[0] = "B" + temp;
            } else {
                gameState[0] = "A" + temp;
            }
        }

    }

    /**
     * Determine whether it's time to change the player.
     * Turn changes if there is no full row in the storage and if factories are empty.
     * @param storage
     * @return boolean value for determine whether to change the player.
     * @author u7235955
     */
    public static boolean isTurn(String storage){
        //System.out.println("Storage: " + storage);
        for (int i = 1; i < storage.length(); i+=3) {
            if(storage.charAt(i) + 1 == storage.charAt(i + 2)){
                return false;
            }
        }
        return true;
    }

    /**
     * To update the discard state for shared state.
     * @param discard
     * @param tile
     * @param tile_count
     * @return new_discard
     * @author u7235955
     */
    public static String updateDiscard(String discard, String tile, int tile_count){
        String new_discard = "D";
        if(tile.equals("a")){
            int number = Integer.parseInt(discard.substring(1, 3));
            number += tile_count - 1;
            if(number < 10){
                new_discard += "0";
            }
            new_discard += number;
            new_discard += discard.substring(3);
        }
        if(tile.equals("b")){
            new_discard += discard.substring(1, 3);
            int number = Integer.parseInt(discard.substring(3, 5));
            number += tile_count - 1;
            if(number < 10){
                new_discard += "0";
            }
            new_discard += number;
            new_discard += discard.substring(5);
        }
        if(tile.equals("c")){
            new_discard += discard.substring(1, 5);
            int number = Integer.parseInt(discard.substring(5, 7));
            number += tile_count - 1;
            if(number < 10){
                new_discard += "0";
            }
            new_discard += number;
            new_discard += discard.substring(7);
        }
        if(tile.equals("d")){
            new_discard += discard.substring(1, 7);
            int number = Integer.parseInt(discard.substring(7, 9));
            number += tile_count - 1;
            if(number < 10){
                new_discard += "0";
            }
            new_discard += number;
            new_discard += discard.substring(9);
        }
        if(tile.equals("e")){
            new_discard += discard.substring(1, 9);
            int number = Integer.parseInt(discard.substring(9, 11));
            number += tile_count - 1;
            if(number < 10){
                new_discard += "0";
            }
            new_discard += number;
        }

        return new_discard;
    }

    /**
     * To update the storage state for new player state.
     * @param storage
     * @param row_position
     * @param tile
     * @param tile_count
     * @return new_storage
     * @author u7235955
     */
    public static String updateStorage(String storage, int row_position, String tile, int tile_count){
        String new_storage = "";
        new_storage = storage.substring(0, row_position);
        String temp = storage.substring(row_position + 2 + 1);
        return new_storage + temp;
    }

    /**
     * To update the mosaic state for new player state.
     * @param mosaic
     * @param tile
     * @param move
     * @return new_mosaic
     * @author u7235955
     */
    public static String updateMosaic(String mosaic, String tile, String move){
        int row = Integer.parseInt(move.substring(1, 2));
        int column = Integer.parseInt(move.substring(2, 3));
        boolean insert = false;
        String new_mosaic = "";
        //System.out.println("Mosaic: " + mosaic);
        for (int i = 2; i < mosaic.length(); i+=3) {
            if (mosaic.charAt(i) - '0' > row){
                new_mosaic = mosaic.substring(0, i - 1);
                new_mosaic += tile;
                new_mosaic += move.substring(1);
                new_mosaic += mosaic.substring(i - 1);
                insert = true;
                break;
            } else {
                if (mosaic.charAt(i) - '0' == row && mosaic.charAt(i + 1) - '0' > column){
                    new_mosaic = mosaic.substring(0, i - 1);
                    new_mosaic += tile;
                    new_mosaic += move.substring(1);
                    new_mosaic += mosaic.substring(i - 1);
                    insert = true;
                    break;
                }
            }
        }
        if (insert){
            return new_mosaic;
        }else{
            return mosaic + tile + move.substring(1);
        }

    }

    /**
     * Calculate the score
     * @param mosaic
     * @param move
     * @param sc old score
     * @return new score
     * @author u7235955
     */
    public static int countScore(String mosaic, String move, int sc){
        int score = sc + 1;
        int [][] mosaicArr = new int [5] [5];
        for (int i = 2; i < mosaic.length(); i+=3) {
            mosaicArr[mosaic.charAt(i) - '0'][mosaic.charAt(i + 1) - '0'] += 1;
        }
        int i = Integer.parseInt(move.substring(1, 2));
        int j = Integer.parseInt(move.substring(2, 3));
        int temp_i = i - 1;
        int temp_j = j - 1;
        boolean horizontal = false;
        boolean vertical = false;
        while(temp_i >= 0 && mosaicArr[temp_i][j] != 0){
            score += 1;
            temp_i -= 1;
            vertical = true;
        }
        temp_i = i + 1;
        while(temp_i < 5 && mosaicArr[temp_i][j] != 0){
            score += 1;
            temp_i += 1;
            vertical = true;
        }
        while(temp_j >= 0 && mosaicArr[i][temp_j]!= 0){
            score += 1;
            temp_j -= 1;
            horizontal = true;
        }
        temp_j = j + 1;
        while(temp_j < 5 && mosaicArr[i][temp_j]!= 0){
            score += 1;
            temp_j += 1;
            horizontal = true;
        }
        // If the tile has adjacent tiles in vertical and horizontal, count it again.
        if (vertical && horizontal){
            score += 1;
        }
        return score;
    }

    public static boolean isStorageContains (String [] gameState, String move){
        String playerState = gameState[1];
        int b = playerState.indexOf("B");
        String playerState1 = "";
        String left = "";
        if(move.charAt(0) == 'B'){
            left = playerState.substring(0, b + 1);
            playerState1 = playerState.substring(b, playerState.length());;
        }else{
            left = playerState.substring(b);
            playerState1 = playerState.substring(0, b);
        }

        int m = playerState1.indexOf("M");
        int s = playerState1.indexOf("S");
        int f = playerState1.indexOf("F");

        String mosaic = playerState1.substring(m, s);
        String storage = playerState1.substring(s, f);
        for (int i = 1; i < storage.length(); i+=3) {
            if (storage.charAt(i) == move.charAt(3)){
                return false;
            }
        }
        return true;
    }

    /**
     * Given a valid game state, return a valid move.
     *
     * @param gameState the game state
     * @return a move for the current game state.
     * TASK 13
     */
    public static String generateAction(String[] gameState) {
        // FIXME Task 13
        Set<String> moves = new HashSet<>();

        // For drafting move
        // What we need are factories and centre

        String[] factoryArr = new String[5];
        String sharedState = gameState[0];
        String sharedState2 = sharedState.substring(1);
        int f = sharedState2.indexOf("F");
        int c = sharedState2.indexOf("C");
        int b = sharedState2.indexOf("B");
        int d = sharedState2.indexOf("D");
        String factory = sharedState2.substring(f, c);
        String centre = sharedState2.substring(c, b);
        //System.out.println(factory);
        //System.out.println(centre);
        if (factory.indexOf("0") != -1){
            factoryArr[0] = factory.substring(2, 6);
        }
        if (factory.indexOf("1") != -1){
            factoryArr[1] = factory.substring(factory.indexOf("1") +1, factory.indexOf("1") + 5);
        }
        if (factory.indexOf("2") != -1){
            factoryArr[2] = factory.substring(factory.indexOf("2") + 1, factory.indexOf("2") + 5);
        }
        if (factory.indexOf("3") != -1){
            factoryArr[3] = factory.substring(factory.indexOf("3") + 1, factory.indexOf("3") + 5);
        }
        if (factory.indexOf("4") != -1){
            factoryArr[4] = factory.substring(factory.indexOf("4") + 1);
        }

        String move = gameState[0].substring(0, 1);
        if (!factory.equals("F")){
            //System.out.println("Here!");
            for (int i = 0; i < 5; i++) {
                if (factoryArr[i] != null){
                    move += i;
                    for (int j = 0; j < 4; j++) {
                        move += String.valueOf(factoryArr[i].charAt(j));
                        for (int k = 0; k < 3; k++) {
                            if (isMoveValid(gameState, move + k) && isStorageContains(gameState, move + k)){
                                //System.out.println(move + k);
                                return move + k;
                            }
                        }
                        move = move.substring(0, 2);
                    }
                    move = move.substring(0, 1);
                }
            }
        }

        move = gameState[0].substring(0, 1) + "C";
        if (!centre.equals("C")) {
            for (int i = 1; i < centre.length(); i++) {
                move += centre.substring(i, i + 1);
                for (int j = 1; j <= 5; j++) {
                    if (j == 5){
                        move += "F";
                    }else{
                        move += j;
                    }
                    if (isMoveValid(gameState, move) && isStorageContains(gameState, move)){
                        return move;
                    }
                    move = move.substring(0, 3);
                }
                move = move.substring(0, 2);
            }
        }


        // For tiling move
        move = gameState[0].substring(0, 1);
        for (int i = 0; i < 5; i++) {
            move += i;
            for (int j = 0; j <= 5; j++) {
                if (j == 5){
                    move += "F";
                }else
                {
                    move += j;
                }
                if (isMoveValid(gameState, move)){
                    moves.add(move);
                    return move;
                }
                move = move.substring(0, 2);
            }
            move = move.substring(0, 1);
        }
        return move;
        // FIXME Task 15 Implement a "smart" generateAction()
    }
}
